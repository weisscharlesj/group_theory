"""Contains chemical group theory functions for calculating numbers and type of irreducible represetantions in a reducible representation and number of IRand Raman active modes. Below uses the inverse method  of solving for irreducible representations described in J. Chem. Educ. 2009, 86, 251-253https://doi.org/10.1021/ed086p251"""import numpy as np# data tables in character_tables.py fileimport charactertables as ctdef get_header(group):    """    Returns the header for a character table given the point group.        Parameters    ----------    group : string        point group Schoelflies notation (e.g., 'C2v')    Returns    -------    tuple with character table header indicating order of symmetry operations     """     print(*ct.headers[group.lower()])def get_point_groups():    """    Returns list of point group Schoenflies notations supported        Parameters    ----------    None        Returns    -------    list of Schoelflies notations for character tables available        """        #print(*headers.keys())    pg = ('C1', 'Cs', 'Ci', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'D2',           'D3', 'D4', 'D5', 'D6', 'C2v', 'C3v', 'C4v', 'C5v', 'C6v', 'C2h',          'C3h', 'C4h', 'C5h', 'C6h', 'D2h', 'D3h', 'D4h', 'D5h', 'D6h', 'D8h',          'D2d', 'D3d', 'D4d', 'D5d', 'D6d', 'S4', 'S6', 'S8', 'T', 'Th', 'Td',          'O', 'Oh', 'I', 'Ih')    print(*pg)def get_mulliken(group):    """    Returns list of mulliken symbols of irreducible reprensentation in order    returned by decomp_reduc()        Parameters    ----------    None        Returns    -------    tuple of mulliken notations for irreducible representation        """        return ct.mulliken[group.lower()]    class Symmetry:    """Symmetry object for working with reducible representations, calculating    number and type of irreducible representations, and calculating IR and    Raman active vibrational modes    """        def __init__(self, gamma, group, vibe_only=True):        self.group = group        self.gamma = gamma        self.vibe_only = vibe_only        def decomp_reduc(self):        """         Decomposes a reducible representation for a specific point group and         returns the number of each irreducible representation in the reducible.                Point groups with imaginary degenerate representations had degenerate        representations merged which required the irreducible representations        to be padded out with zeros. This leads to extra zeros in the returned        array containing the number of irreducibles in the provided reducible.                Parameters        ----------        gamma: array_like               reducible representation        group: str            point group in Schoelflies notation (e.g., 'C2v')                    Returns        -------        array_like collection with  number of each irreducible representation, in        order, in the provided reducible representation            Examples        --------        >>> decomp_reduc([9, -1, 3, 1], 'C2v')        array([3, 1, 3, 2])                >>> decomp_reduc([15, 0, 0, 7, -2, -2], 'C3h')        array([3, 4, 1, 1])                """              table = ct.tables[self.group.lower()]        gamma = np.array(self.gamma)                if self.group.lower() == 'c1':            return self.gamma                else:                # number of each irreducible representation present in provided reducible            mask = np.array(ct.masks[self.group.lower()], dtype=bool)            n_i = gamma.dot(np.linalg.inv(table)).real[mask]                #print(np.rint(n_i).astype(int)[:n_irred])                          return np.rint(n_i).astype(int)            def vibe_modes(self):        """         Returns the number of vibrational modes after rotation and translation        are subtracted out                Parameters        ----------        irreducibles: array_like            number of each irreducible representation        group: str            point group in Schoelflies notation (e.g., 'C2v')            Examples        --------        >>> vide_modes([3, 1, 3, 2, 'C2v')        array([2, 0, 1, 0])                """                    rot_trans = ct.rot_trans_modes[self.group.lower()]        irreducibles = self.decomp_reduc()                    return np.array(irreducibles) - np.array(rot_trans)                def ir_active(self):        """         Returns the number of IR active modes given the number of irreducible        representations by subtracting rotational and translational modes        and checking for only IR active modes                Parameters        ----------        irreducibles: array_like            number of each irreducible representation        group: str            point group in Schoelflies notation (e.g., 'C2v')            Examples        --------        >>> ir_active([3, 1, 3, 2, 'C2v')        array([2, 0, 1, 0])                """        irreducibles = self.decomp_reduc()                if self.vibe_only == True:            return irreducibles * np.array(ct.IR_active[self.group])                if self.vibe_only == False:            rot_trans = np.array(ct.rot_trans_modes[self.group.lower()])                    vibrations = np.array(irreducibles) - rot_trans                    return vibrations * np.array(ct.IR_active[self.group.lower()])        def raman_active(self):        """         Returns the number of Raman active modes given the number of irreducible        representations by subtracting rotational and translational modes        and checking for only Raman active modes                Parameters        ----------        irreducibles: array_like            number of each irreducible representation        group: str            point group in Schoelflies notation (e.g., 'C2v')            Examples        --------        >>> raman_active([3, 1, 3, 2], 'C2v')        array([2, 0, 1, 0])                """                rot_trans = np.array(ct.rot_trans_modes[self.group.lower()])        irreducibles = self.decomp_reduc()            vibrations = np.array(irreducibles) - rot_trans            return vibrations * np.array(ct.Raman_active[self.group.lower()])    def gen_reducible(n_irred, group):    """     Returns a reducible representation given the number of count of each     irreducible representation and the point group.        Parameters    ----------    count: array_like        number of each irreducible representations in the generated reducible        representation    group: str        point group in Schoelflies notation (e.g., 'C2v')    Examples    --------    >>> generate_reducible([1, 0, 1, 0], 'c2v')    array([2, 0, 2, 0])        >>> generate_reducible([3, 1, 3, 2], 'C2v')    array([9, -1, 3, 1])        >>> generate_reducible([3, 1, 1], 'C3v')    array([6, 3, 2])            """    # list of point groups with doubly degenerate complex representations    #doubly_complex = ('c3', 'c4', 'c6', 'c7', 'c8', 'c3h', 'c4h', 'c5h',    #                  'c6h', 's4', 's6', 's8', 't', 'th')        irred_sum = np.sum((ct.tables[group.lower()].T * n_irred).T, axis=0)        return np.rint(irred_sum).astype(int)def get_reducible_atoms(n_atoms, group):    """    Returns a reducible representation given the number of atoms that do not    move (translate) resulting from each symmetry operation.    Parameters    ----------    n_atoms : array_like        Number of atoms that remain stationary during each symmetry operation.    group : string        The name of the point group (e.g., 'C2v').    Returns    -------    Numpy array of integers.    """    n_atoms = np.array(n_atoms)        if np.all(np.mod(n_atoms, 1) == 0):        return n_atoms * np.array(ct.atom_contribution[group])        else:        print('Number of stationary atoms (n_atoms) must be a integer value')